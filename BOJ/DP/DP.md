# DP

## [9095 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

    void DP()
    {
        D[1] = 1;
        D[2] = 2;
        D[3] = 4;

        for (int i = 4; i < 11; i++)
            D[i] = D[i - 1] + D[i - 2] + D[i - 3];
    }

## [2579 계단 오르기](https://www.acmicpc.net/problem/2579)

계단이 한 개일 때는 하나만 오르는 게 최대,
계단이 두 개일 때는 둘 다 오르는 게 최대,
계단이 세 개일 때는 1,3 혹은 2,3 둘 중에 하나가 최대.(여기까지 초기 값)

n번 계단에 도달하는 방법은 두 계단 올라 오거나 한 계단 올라 오기.
즉, n번 계단에서 값을 가지는 경우는

1. n번 계단 값 + n - 2번 계단의 토탈 점수
2. n번 계단 값 + n - 1번 계단 값 + n - 3번 계단의 토탈 점수 (한 계단 올라온 거면 무조건 n - 3을 밟고 와야함.)

   for (int i = 3; i < n; i++)
   {
   answer[i] = max(answer[i - 2] + stairs[i], answer[i - 3] + stairs[i - 1] + stairs[i]);
   }

---

## [LeetCode] Coin Change

memset()과 fill()의 차이
memset은 처리 단위가 1byte이기 때문에 0이나 -1로 초기화할 때 유리하다. (처리 속도가 미세하게 빠름)
fill은 자료형 그 자체로 처리하기 때문에 그 외의 모든 값으로 초기화할 때 안전하다.

d[n]은 n원을 만들기 위해 필요한 최소한의 동전의 개수를 저장한다.
예를 들어 동전이 1원, 2원, 5원이 있다고 하자.
d[7]를 만든다면 7원을 만들기 위해 사용할 수 있는 동전의 조합 중 최소값을 저장하는 것이다. 가능한 조합은 아래와 같다.

- d[6] + 1원의 조합
- d[5] + 2원의 조합
- d[2] + 5원의 조합

DP의 특징인 메모라이제이션 + 바텀 업으로 d[7]에 도달할 때까지 d[6], d[5], d[2]를 채우면 된다.
