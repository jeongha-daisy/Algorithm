# DP

## [9095 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

    void DP()
    {
        D[1] = 1;
        D[2] = 2;
        D[3] = 4;

        for (int i = 4; i < 11; i++)
            D[i] = D[i - 1] + D[i - 2] + D[i - 3];
    }

## [2579 계단 오르기](https://www.acmicpc.net/problem/2579)

계단이 한 개일 때는 하나만 오르는 게 최대,
계단이 두 개일 때는 둘 다 오르는 게 최대,
계단이 세 개일 때는 1,3 혹은 2,3 둘 중에 하나가 최대.(여기까지 초기 값)

n번 계단에 도달하는 방법은 두 계단 올라 오거나 한 계단 올라 오기.
즉, n번 계단에서 값을 가지는 경우는

1. n번 계단 값 + n - 2번 계단의 토탈 점수
2. n번 계단 값 + n - 1번 계단 값 + n - 3번 계단의 토탈 점수 (한 계단 올라온 거면 무조건 n - 3을 밟고 와야함.)

   for (int i = 3; i < n; i++)
   {
   answer[i] = max(answer[i - 2] + stairs[i], answer[i - 3] + stairs[i - 1] + stairs[i]);
   }

## [11726 2×n 타일링](https://www.acmicpc.net/problem/11726)

최종 계산 값에 10,007을 나누면 틀리고, 계산 중에 나누는 방식이 맞는 이유:
1000번째 피보나치 수는 매우 큰 수로, 정확한 값은 218922995834555169026... (이하 생략)으로 시작하며, 약 209자리의 숫자로 이루어져 있다. long long int도 19자리수까지밖에 표현하지 못하기 때문에 중간부터 제대로된 값을 저장하지 못한다. 따라서 계산 중에 나누어 저장하는 것이 맞다!

두 계산 방식이 같은 결과를 낳을 수 있는 이유:
모듈러 연산(나머지 연산)의 성질 때문.
(a+b) mod m = ((a mod m)+(b mod m)) mod m

10,007의미: 10,000보다 큰 최소의 소수

## [11659 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)

### 누적합

누적합 아이디어는 배열에 들어있는 값이 바뀌지 않는다는 점을 이용한다. 배열이 변하지 않으니 구간의 합도 변하지 않는다. 따라서, 앞에서부터 차례대로 누적된 합을 구해놓고 이를 이용해서 구간의 합을 구할 수 있다.

endl 은 줄을 넘긴 후 flush 연산을 수행하기 때문에 대부분의 경우 '\n'이 적당하다.

## [1912 연속합](https://www.acmicpc.net/problem/1912)

i번째 수를 반드시 포함하는 누적합의 최대값을 저장한다.

    cumulativeSum[i] = max(numbers[i], cumulativeSum[i - 1] + numbers[i]);

i-1까지 저장된 누적합이 음수이면, 누적합을 그냥 새로 시작한다. (음수는 오히려 최대값과 멀어지게 함)

## [11053 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

각 원소를 끝으로 하는 증가 부분 수열의 최대 길이를 구한다. 수열이 한 개일 때 → 길이는 1
i번째 수를 기준으로, 그 앞의 j번째 수들 중 값이 더 작은 경우에만 이어 붙일 수 있다.

---

## [LeetCode] Coin Change

memset()과 fill()의 차이
memset은 처리 단위가 1byte이기 때문에 0이나 -1로 초기화할 때 유리하다. (처리 속도가 미세하게 빠름)
fill은 자료형 그 자체로 처리하기 때문에 그 외의 모든 값으로 초기화할 때 안전하다.

d[n]은 n원을 만들기 위해 필요한 최소한의 동전의 개수를 저장한다.
예를 들어 동전이 1원, 2원, 5원이 있다고 하자.
d[7]를 만든다면 7원을 만들기 위해 사용할 수 있는 동전의 조합 중 최소값을 저장하는 것이다. 가능한 조합은 아래와 같다.

- d[6] + 1원의 조합
- d[5] + 2원의 조합
- d[2] + 5원의 조합

DP의 특징인 메모라이제이션 + 바텀 업으로 d[7]에 도달할 때까지 d[6], d[5], d[2]를 채우면 된다.
